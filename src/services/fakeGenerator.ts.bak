// çº¯å‰ç«¯å‡ç”Ÿæˆå™¨ - å‚è€ƒ48ä¸ªåƒç´ æ€ªç‰©ä¼˜åŒ–ç‰ˆ

// ç®€å•çš„å“ˆå¸Œå‡½æ•°
function simpleHash(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash);
}

// æ ¹æ®å…³é”®è¯é€‰æ‹©é¢œè‰²æ–¹æ¡ˆ(å‚è€ƒç´ æ)
function getColorPalette(description: string, seed: number): any {
  const desc = description.toLowerCase();
  const rand = (offset: number) => (seed + offset) % 100;
  
  // æ ¹æ®æè¿°é€‰æ‹©åŸºç¡€è‰²ç³»
  let palette: any;
  
  if (desc.includes('fire') || desc.includes('red') || desc.includes('ç«') || desc.includes('çº¢')) {
    // çº¢è‰²è˜‘è‡ç³» - æš–è‰²è°ƒ
    palette = {
      main: `hsl(${rand(0) % 30}, 80%, 55%)`,
      dark: `hsl(${rand(0) % 30}, 70%, 35%)`,
      light: `hsl(${rand(0) % 30}, 85%, 75%)`,
      accent: `hsl(30, 75%, 65%)`,
      outline: '#2a1810'
    };
  } else if (desc.includes('green') || desc.includes('slime') || desc.includes('ç»¿') || desc.includes('å²è±å§†')) {
    // ç»¿è‰²å²è±å§†ç³» - æ¸…æ–°è‰²è°ƒ
    palette = {
      main: `hsl(${120 + rand(0) % 60}, 65%, 50%)`,
      dark: `hsl(${120 + rand(0) % 60}, 70%, 30%)`,
      light: `hsl(${120 + rand(0) % 60}, 75%, 70%)`,
      accent: `hsl(${160 + rand(0) % 30}, 60%, 55%)`,
      outline: '#1a3a1a'
    };
  } else if (desc.includes('blue') || desc.includes('ice') || desc.includes('è“') || desc.includes('å†°')) {
    // è“è‰²å†°éœœç³» - å†·è‰²è°ƒ
    palette = {
      main: `hsl(${180 + rand(0) % 60}, 70%, 55%)`,
      dark: `hsl(${180 + rand(0) % 60}, 75%, 35%)`,
      light: `hsl(${180 + rand(0) % 60}, 80%, 75%)`,
      accent: `hsl(${200 + rand(0) % 40}, 65%, 60%)`,
      outline: '#0a2a3a'
    };
  } else if (desc.includes('purple') || desc.includes('dark') || desc.includes('ç´«') || desc.includes('æš—')) {
    // ç´«è‰²é»‘æš—ç³» - ç¥ç§˜è‰²è°ƒ
    palette = {
      main: `hsl(${270 + rand(0) % 60}, 60%, 45%)`,
      dark: `hsl(${270 + rand(0) % 60}, 65%, 25%)`,
      light: `hsl(${270 + rand(0) % 60}, 70%, 65%)`,
      accent: `hsl(${300 + rand(0) % 40}, 55%, 50%)`,
      outline: '#1a0a2a'
    };
  } else {
    // éšæœºæ··åˆè‰²ç³»
    const baseHue = rand(0) % 360;
    palette = {
      main: `hsl(${baseHue}, 70%, 50%)`,
      dark: `hsl(${baseHue}, 75%, 30%)`,
      light: `hsl(${baseHue}, 80%, 70%)`,
      accent: `hsl(${(baseHue + 40) % 360}, 65%, 55%)`,
      outline: '#1a1a1a'
    };
  }
  
  // æ·»åŠ å›ºå®šçš„ç™½è‰²å’Œé»‘è‰²ç”¨äºçœ¼ç›
  palette.white = '#ffffff';
  palette.black = '#000000';
  palette.eyeHighlight = '#ffffff';
  
  return palette;
}

// ç”Ÿæˆåƒç´ æ€ªç‰©å›¾ç‰‡
function generatePixelCreature(description: string, size: number = 64): string {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 512;
  const ctx = canvas.getContext('2d')!;
  
  // æ¸…ç©ºç”»å¸ƒ
  ctx.clearRect(0, 0, 512, 512);
  
  // ä½¿ç”¨æè¿°ç”Ÿæˆéšæœºç§å­
  const seed = simpleHash(description);
  
  // ç”Ÿæˆé¢œè‰²
  const mainColor = generateColor(seed, 0);
  const shadowColor = generateColor(seed, 30);
  const highlightColor = generateColor(seed, 60);
  const accentColor = generateColor(seed, 180);
  
  // åƒç´ å—å¤§å°
  const pixelSize = 512 / size;
  
  // ç»˜åˆ¶åƒç´ åŒ–çš„æ€ªç‰©
  const centerX = Math.floor(size / 2);
  const bodyWidth = Math.floor(size / 3);
  const bodyHeight = Math.floor(size / 2);
  const bodyY = Math.floor(size / 3);
  
  // ç»˜åˆ¶å‡½æ•°
  const drawPixel = (x: number, y: number, color: string) => {
    ctx.fillStyle = color;
    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
  };
  
  // èº«ä½“
  for (let y = bodyY; y < bodyY + bodyHeight; y++) {
    for (let x = centerX - bodyWidth; x < centerX + bodyWidth; x++) {
      drawPixel(x, y, mainColor);
    }
  }
  
  // çœ¼ç›
  const eyeY = bodyY + Math.floor(bodyHeight / 4);
  drawPixel(centerX - 4, eyeY, '#ffffff');
  drawPixel(centerX - 4, eyeY + 1, '#ffffff');
  drawPixel(centerX + 4, eyeY, '#ffffff');
  drawPixel(centerX + 4, eyeY + 1, '#ffffff');
  
  // ç³å­”
  drawPixel(centerX - 4, eyeY + 1, '#000000');
  drawPixel(centerX + 4, eyeY + 1, '#000000');
  
  // å˜´å·´
  const mouthY = eyeY + 6;
  for (let x = centerX - 3; x <= centerX + 3; x++) {
    drawPixel(x, mouthY, accentColor);
  }
  
  // è£…é¥°ç‚¹
  const numDots = 5 + (seed % 10);
  for (let i = 0; i < numDots; i++) {
    const dotSeed = seed + i * 1000;
    const dotX = centerX - bodyWidth + 2 + (dotSeed % (bodyWidth * 2 - 4));
    const dotY = bodyY + 2 + ((dotSeed / 100) % (bodyHeight - 4));
    drawPixel(Math.floor(dotX), Math.floor(dotY), highlightColor);
  }
  
  return canvas.toDataURL('image/png');
}

// ç”ŸæˆéŸ³é¢‘æ•°æ®
function generateAudio(description: string): string {
  // åˆ›å»ºä¸€ä¸ªç®€å•çš„éŸ³é¢‘ä¸Šä¸‹æ–‡
  const sampleRate = 22050;
  const duration = 0.5;
  const samples = Math.floor(sampleRate * duration);
  
  // åˆ›å»ºéŸ³é¢‘æ•°æ®
  const audioData = new Int16Array(samples);
  const seed = simpleHash(description);
  const frequency = 200 + (seed % 400);
  
  for (let i = 0; i < samples; i++) {
    const t = i / sampleRate;
    const value = Math.sin(2 * Math.PI * frequency * t) * 0.3;
    const envelope = Math.exp(-t * 3); // æ·¡å‡º
    audioData[i] = Math.floor(value * envelope * 32767);
  }
  
  // åˆ›å»º WAV æ–‡ä»¶å¤´
  const wavHeader = new ArrayBuffer(44);
  const view = new DataView(wavHeader);
  
  // "RIFF" chunk descriptor
  view.setUint32(0, 0x52494646, false); // "RIFF"
  view.setUint32(4, 36 + samples * 2, true); // file size - 8
  view.setUint32(8, 0x57415645, false); // "WAVE"
  
  // "fmt " sub-chunk
  view.setUint32(12, 0x666d7420, false); // "fmt "
  view.setUint32(16, 16, true); // subchunk size
  view.setUint16(20, 1, true); // audio format (PCM)
  view.setUint16(22, 1, true); // number of channels
  view.setUint32(24, sampleRate, true); // sample rate
  view.setUint32(28, sampleRate * 2, true); // byte rate
  view.setUint16(32, 2, true); // block align
  view.setUint16(34, 16, true); // bits per sample
  
  // "data" sub-chunk
  view.setUint32(36, 0x64617461, false); // "data"
  view.setUint32(40, samples * 2, true); // data size
  
  // åˆå¹¶å¤´éƒ¨å’ŒéŸ³é¢‘æ•°æ®
  const wavFile = new Uint8Array(44 + samples * 2);
  wavFile.set(new Uint8Array(wavHeader), 0);
  wavFile.set(new Uint8Array(audioData.buffer), 44);
  
  // è½¬æ¢ä¸º base64
  let binary = '';
  for (let i = 0; i < wavFile.length; i++) {
    binary += String.fromCharCode(wavFile[i]);
  }
  return 'data:audio/wav;base64,' + btoa(binary);
}

// ä¸»ç”Ÿæˆå‡½æ•°
export async function generateCreatureOffline(
  description: string,
  pixelSize: string = '32px',
  quantity: number = 4
): Promise<any> {
  console.log('ğŸ¨ ä½¿ç”¨çº¯å‰ç«¯ç”Ÿæˆå™¨:', description);
  
  // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
  await new Promise(resolve => setTimeout(resolve, 500));
  
  const images: string[] = [];
  const audios: string[] = [];
  
  const size = parseInt(pixelSize.replace('px', ''));
  
  for (let i = 0; i < quantity; i++) {
    // ä¸ºæ¯ä¸ªå˜ä½“æ·»åŠ ä¸åŒçš„åç¼€
    const variantDesc = `${description}_variant_${i}`;
    images.push(generatePixelCreature(variantDesc, size));
    audios.push(generateAudio(variantDesc));
  }
  
  return {
    success: true,
    message: 'ç”ŸæˆæˆåŠŸï¼(çº¯å‰ç«¯æ¨¡å¼)',
    images,
    audios,
    prompt: description,
    method: 'Frontend Generator'
  };
}
